<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Character class - Ruby Regexp</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Example based guide to mastering Ruby Regexp">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
        <link rel="stylesheet" href="custom.css">
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="cover.html">Cover</a></li><li class="chapter-item expanded affix "><a href="buy.html">Buy PDF/EPUB versions</a></li><li class="chapter-item expanded "><a href="preface.html"><strong aria-hidden="true">1.</strong> Preface</a></li><li class="chapter-item expanded "><a href="why-is-it-needed.html"><strong aria-hidden="true">2.</strong> Why is it needed?</a></li><li class="chapter-item expanded "><a href="regexp-introduction.html"><strong aria-hidden="true">3.</strong> Regexp introduction</a></li><li class="chapter-item expanded "><a href="anchors.html"><strong aria-hidden="true">4.</strong> Anchors</a></li><li class="chapter-item expanded "><a href="alternation-and-grouping.html"><strong aria-hidden="true">5.</strong> Alternation and Grouping</a></li><li class="chapter-item expanded "><a href="escaping-metacharacters.html"><strong aria-hidden="true">6.</strong> Escaping metacharacters</a></li><li class="chapter-item expanded "><a href="dot-metacharacter-and-quantifiers.html"><strong aria-hidden="true">7.</strong> Dot metacharacter and Quantifiers</a></li><li class="chapter-item expanded "><a href="interlude-tools-for-debugging-and-visualization.html"><strong aria-hidden="true">8.</strong> Interlude: Tools for debugging and visualization</a></li><li class="chapter-item expanded "><a href="working-with-matched-portions.html"><strong aria-hidden="true">9.</strong> Working with matched portions</a></li><li class="chapter-item expanded "><a href="character-class.html" class="active"><strong aria-hidden="true">10.</strong> Character class</a></li><li class="chapter-item expanded "><a href="groupings-and-backreferences.html"><strong aria-hidden="true">11.</strong> Groupings and backreferences</a></li><li class="chapter-item expanded "><a href="interlude-common-tasks.html"><strong aria-hidden="true">12.</strong> Interlude: Common tasks</a></li><li class="chapter-item expanded "><a href="lookarounds.html"><strong aria-hidden="true">13.</strong> Lookarounds</a></li><li class="chapter-item expanded "><a href="modifiers.html"><strong aria-hidden="true">14.</strong> Modifiers</a></li><li class="chapter-item expanded "><a href="unicode.html"><strong aria-hidden="true">15.</strong> Unicode</a></li><li class="chapter-item expanded "><a href="further-reading.html"><strong aria-hidden="true">16.</strong> Further Reading</a></li><li class="chapter-item expanded "><a href="Exercise_solutions.html"><strong aria-hidden="true">17.</strong> Exercise Solutions</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Ruby Regexp</h1>

                    <div class="right-buttons">
                        
                        <a href="https://github.com/learnbyexample/Ruby_Regexp" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#character-class" id="character-class">Character class</a></h1>
<p>This chapter will discuss how to create your own custom placeholders to match limited set of characters and various metacharacters applicable inside character classes. You'll also learn various predefined character sets.</p>
<h2><a class="header" href="#custom-character-sets" id="custom-character-sets">Custom character sets</a></h2>
<p>Characters enclosed inside <code>[]</code> metacharacters is a character class (or set). It will result in matching any one of those characters once. It is similar to using single character alternations inside a grouping, but without the drawbacks of a capture group. In addition, character classes have their own versions of metacharacters and provide special predefined sets for common use cases. Quantifiers are applicable to character classes as well.</p>
<pre><code class="language-ruby"># same as: /cot|cut/ or /c(o|u)t/
&gt;&gt; %w[cute cat cot coat cost scuttle].grep(/c[ou]t/)
=&gt; [&quot;cute&quot;, &quot;cot&quot;, &quot;scuttle&quot;]

# same as: /(a|e|o)+t/
&gt;&gt; 'meeting cute boat site foot'.gsub(/[aeo]+t/, 'X')
=&gt; &quot;mXing cute bX site fX&quot;
</code></pre>
<h2><a class="header" href="#range-of-characters" id="range-of-characters">Range of characters</a></h2>
<p>Character classes have their own metacharacters to help define the sets succinctly. Metacharacters outside of character classes like <code>^</code>, <code>$</code>, <code>()</code> etc either don't have special meaning or have completely different one inside the character classes. First up, the <code>-</code> metacharacter that helps to define a range of characters instead of having to specify them all individually.</p>
<pre><code class="language-ruby"># all digits, same as: scan(/[0123456789]+/)
&gt;&gt; 'Sample123string42with777numbers'.scan(/[0-9]+/)
=&gt; [&quot;123&quot;, &quot;42&quot;, &quot;777&quot;]

# whole words made up of lowercase alphabets only
&gt;&gt; 'coat Bin food tar12 best'.scan(/\b[a-z]+\b/)
=&gt; [&quot;coat&quot;, &quot;food&quot;, &quot;best&quot;]

# whole words made up of lowercase alphabets and digits only
&gt;&gt; 'coat Bin food tar12 best'.scan(/\b[a-z0-9]+\b/)
=&gt; [&quot;coat&quot;, &quot;food&quot;, &quot;tar12&quot;, &quot;best&quot;]

# whole words made up of lowercase alphabets, but starting with 'p' to 'z'
&gt;&gt; 'coat tin food put stoop best'.scan(/\b[p-z][a-z]*\b/)
=&gt; [&quot;tin&quot;, &quot;put&quot;, &quot;stoop&quot;]

# whole words made up of only 'a' to 'f' and 'p' to 't' lowercase alphabets
&gt;&gt; 'coat tin food put stoop best'.scan(/\b[a-fp-t]+\b/)
=&gt; [&quot;best&quot;]
</code></pre>
<h2><a class="header" href="#negating-character-sets" id="negating-character-sets">Negating character sets</a></h2>
<p>Next metacharacter is <code>^</code> which has to specified as the first character of the character class. It negates the set of characters, so all characters other than those specified will be matched. As highlighted earlier, handle negative logic with care, you might end up matching more than you wanted. Also, these examples below are all excellent places to use possessive quantifier as there is no backtracking involved.</p>
<pre><code class="language-ruby"># all non-digits
&gt;&gt; 'Sample123string42with777numbers'.scan(/[^0-9]+/)
=&gt; [&quot;Sample&quot;, &quot;string&quot;, &quot;with&quot;, &quot;numbers&quot;]

# remove first two columns where : is delimiter
&gt;&gt; 'foo:123:bar:baz'.sub(/\A([^:]+:){2}/, '')
=&gt; &quot;bar:baz&quot;

# deleting characters at end of string based on a delimiter
&gt;&gt; 'foo=42; baz=123'.sub(/=[^=]+\z/, '')
=&gt; &quot;foo=42; baz&quot;

&gt;&gt; dates = '2020/04/25,1986/Mar/02,77/12/31'
# Note that the third character set negates comma as well
# and comma is matched optionally outside the capture groups
&gt;&gt; dates.scan(%r{([^/]+)/([^/]+)/([^/,]+),?})
=&gt; [[&quot;2020&quot;, &quot;04&quot;, &quot;25&quot;], [&quot;1986&quot;, &quot;Mar&quot;, &quot;02&quot;], [&quot;77&quot;, &quot;12&quot;, &quot;31&quot;]]
</code></pre>
<p>Sometimes, it is easier to use positive character class and invert the boolean result instead of negating the character class.</p>
<pre><code class="language-ruby">&gt;&gt; words = %w[tryst fun glyph pity why]

# words not containing vowel characters
&gt;&gt; words.grep(/\A[^aeiou]+\z/)
=&gt; [&quot;tryst&quot;, &quot;glyph&quot;, &quot;why&quot;]

# easier to write and maintain
# but this'll match empty strings too unlike the previous solution
&gt;&gt; words.grep_v(/[aeiou]/)
=&gt; [&quot;tryst&quot;, &quot;glyph&quot;, &quot;why&quot;]
</code></pre>
<h2><a class="header" href="#set-intersection" id="set-intersection">Set intersection</a></h2>
<p>Using <code>&amp;&amp;</code> between two sets of characters will result in matching only the intersection of those two sets. To aid in such definitions, you can use <code>[]</code> in nested fashion.</p>
<pre><code class="language-ruby"># [^aeiou] will match any non-vowel character
# which means space is also a valid character to be matched
&gt;&gt; 'tryst glyph pity why'.scan(/\b[^aeiou]+\b/)
=&gt; [&quot;tryst glyph &quot;, &quot; why&quot;]

# [a-z&amp;&amp;[^aeiou]] will be intersection of a-z and non-vowel characters
# this results in positive definition of characters to match
&gt;&gt; 'tryst glyph pity why'.scan(/\b[a-z&amp;&amp;[^aeiou]]+\b/)
=&gt; [&quot;tryst&quot;, &quot;glyph&quot;, &quot;why&quot;]
</code></pre>
<h2><a class="header" href="#matching-metacharacters-literally" id="matching-metacharacters-literally">Matching metacharacters literally</a></h2>
<p>Similar to other metacharacters, prefix <code>\</code> to character class metacharacters to match them literally. Some of them can be achieved by different placement as well.</p>
<p><code>-</code> should be first or last character or escaped using <code>\</code>.</p>
<pre><code class="language-ruby">&gt;&gt; 'ab-cd gh-c 12-423'.scan(/\b[a-z-]{2,}\b/)
=&gt; [&quot;ab-cd&quot;, &quot;gh-c&quot;]
&gt;&gt; 'ab-cd gh-c 12-423'.scan(/\b[a-z\-0-9]{2,}\b/)
=&gt; [&quot;ab-cd&quot;, &quot;gh-c&quot;, &quot;12-423&quot;]
</code></pre>
<p><code>^</code> should be other than first character or escaped using <code>\</code>.</p>
<pre><code class="language-ruby">&gt;&gt; 'f*(a^b) - 3*(a+b)'.scan(/a[+^]b/)
=&gt; [&quot;a^b&quot;, &quot;a+b&quot;]
&gt;&gt; 'f*(a^b) - 3*(a+b)'.scan(/a[\^+]b/)
=&gt; [&quot;a^b&quot;, &quot;a+b&quot;]
</code></pre>
<p><code>[</code>, <code>]</code> and <code>\</code> should be escaped using <code>\</code>.</p>
<pre><code class="language-ruby">&gt;&gt; 'words[5] = tea'[/[a-z\[\]0-9]+/]
=&gt; &quot;words[5]&quot;

&gt;&gt; puts '5ba\babc2'[/[a\\b]+/]
ba\bab
</code></pre>
<h2><a class="header" href="#escape-sequence-character-sets" id="escape-sequence-character-sets">Escape sequence character sets</a></h2>
<p>Commonly used character sets have predefined escape sequences:</p>
<ul>
<li><code>\w</code> is equivalent to <code>[A-Za-z0-9_]</code> for matching word characters (recall the definition for word boundaries)</li>
<li><code>\d</code> is equivalent to <code>[0-9]</code> for matching digit characters</li>
<li><code>\s</code> is equivalent to <code>[ \t\r\n\f\v]</code> for matching whitespace characters</li>
<li><code>\h</code> is equivalent to <code>[0-9a-fA-F]</code> for matching hexadecimal characters</li>
</ul>
<p>These escape sequences can be used as a standalone pattern or inside a character class.</p>
<pre><code class="language-ruby">&gt;&gt; '128A foo1 fe32 34 bar'.scan(/\b\h+\b/)
=&gt; [&quot;128A&quot;, &quot;fe32&quot;, &quot;34&quot;]
&gt;&gt; '128A foo1 fe32 34 bar'.scan(/\b\h+\b/).map(&amp;:hex)
=&gt; [4746, 65074, 52]

&gt;&gt; 'Sample123string42with777numbers'.split(/\d+/)
=&gt; [&quot;Sample&quot;, &quot;string&quot;, &quot;with&quot;, &quot;numbers&quot;]
&gt;&gt; 'foo=5, bar=3; x=83, y=120'.scan(/\d+/).map(&amp;:to_i)
=&gt; [5, 3, 83, 120]

&gt;&gt; 'sea eat car rat eel tea'.scan(/\b\w/).join
=&gt; &quot;secret&quot;

&gt;&gt; 'tea sea-pit sit-lean bean'.scan(/[\w\s]+/)
=&gt; [&quot;tea sea&quot;, &quot;pit sit&quot;, &quot;lean bean&quot;]
</code></pre>
<p>And negative logic strikes again. Use <code>\W</code>, <code>\D</code>, <code>\S</code> and <code>\H</code> respectively for their negated sets.</p>
<pre><code class="language-ruby">&gt;&gt; 'Sample123string42with777numbers'.gsub(/\D+/, '-')
=&gt; &quot;-123-42-777-&quot;

&gt;&gt; 'foo=5, bar=3; x=83, y=120'.gsub(/\W+/, '')
=&gt; &quot;foo5bar3x83y120&quot;

&gt;&gt; &quot;   1..3  \v\f  foo_baz 42\tzzz   \r\n1-2-3  &quot;.scan(/\S+/)
=&gt; [&quot;1..3&quot;, &quot;foo_baz&quot;, &quot;42&quot;, &quot;zzz&quot;, &quot;1-2-3&quot;]
</code></pre>
<p><code>\R</code> matches line break characters <code>\n</code>, <code>\v</code>, <code>\f</code>, <code>\r</code>, <code>\u0085</code> (next line), <code>\u2028</code> (line separator), <code>\u2029</code> (paragraph separator) or <code>\r\n</code>. Unlike other escapes, <code>\R</code> cannot be used inside a character class.</p>
<pre><code class="language-ruby">&gt;&gt; &quot;food\r\ngood&quot;[/d\Rg/]
=&gt; &quot;d\r\ng&quot;
</code></pre>
<h2><a class="header" href="#named-character-sets" id="named-character-sets">Named character sets</a></h2>
<p>Ruby also provides named character sets, which are Unicode aware unlike escape sequence sets which are limited only to ASCII characters. A named character set is defined by a name enclosed between <code>[:</code> and <code>:]</code> and has to be used within a character class <code>[]</code>, along with any other characters as needed. Using <code>[:^</code> instead of <code>[:</code> will negate the named set.</p>
<p>Four of the escape sequences presented above have named set equivalents. See <a href="https://ruby-doc.org/core-2.7.1/Regexp.html#class-Regexp-label-Character+Classes">ruby-doc: Character Classes</a> for full list and details.</p>
<pre><code class="language-ruby"># similar to: /\d+/ or /[0-9]+/
&gt;&gt; 'Sample123string42with777numbers'.split(/[[:digit:]]+/)
=&gt; [&quot;Sample&quot;, &quot;string&quot;, &quot;with&quot;, &quot;numbers&quot;]

# similar to: /\S+/
&gt;&gt; &quot;   1..3  \v\f  foo_baz 42\tzzz   \r\n1-2-3  &quot;.scan(/[[:^space:]]+/)
=&gt; [&quot;1..3&quot;, &quot;foo_baz&quot;, &quot;42&quot;, &quot;zzz&quot;, &quot;1-2-3&quot;]

# similar to: /[\w\s]+/
&gt;&gt; 'tea sea-pit sit-lean bean'.scan(/[[:word:][:space:]]+/)
=&gt; [&quot;tea sea&quot;, &quot;pit sit&quot;, &quot;lean bean&quot;]
</code></pre>
<p>Here's some named character sets which do not have escape sequence versions:</p>
<pre><code class="language-ruby"># similar to: /[a-zA-Z]+/
&gt;&gt; 'Sample123string42with777numbers'.scan(/[[:alpha:]]+/)
=&gt; [&quot;Sample&quot;, &quot;string&quot;, &quot;with&quot;, &quot;numbers&quot;]

# remove all punctuation characters
&gt;&gt; ip = '&quot;Hi&quot;, there! How *are* you? All fine here.'
&gt;&gt; ip.gsub(/[[:punct:]]+/, '')
=&gt; &quot;Hi there How are you All fine here&quot;
# remove all punctuation characters except . ! and ?
&gt;&gt; ip.gsub(/[[^.!?]&amp;&amp;[:punct:]]+/, '')
=&gt; &quot;Hi there! How are you? All fine here.&quot;
</code></pre>
<h2><a class="header" href="#numeric-ranges" id="numeric-ranges">Numeric ranges</a></h2>
<p>Character classes can also be used to construct numeric ranges.</p>
<pre><code class="language-ruby"># numbers between 10 to 29
&gt;&gt; '23 154 12 26 98234'.scan(/\b[12]\d\b/)
=&gt; [&quot;23&quot;, &quot;12&quot;, &quot;26&quot;]

# numbers &gt;= 100
&gt;&gt; '23 154 12 26 98234'.scan(/\b\d{3,}\b/)
=&gt; [&quot;154&quot;, &quot;98234&quot;]

# numbers &gt;= 100 if there are leading zeros
&gt;&gt; '0501 035 154 12 26 98234'.scan(/\b0*+\d{3,}\b/)
=&gt; [&quot;0501&quot;, &quot;154&quot;, &quot;98234&quot;]
</code></pre>
<p>However, it is easy to miss corner cases and some ranges are complicated to design. In such cases, it is better to convert the matched portion to appropriate numeric format first.</p>
<pre><code class="language-ruby"># numbers &lt; 350
&gt;&gt; '45 349 651 593 4 204'.scan(/\d++/).filter { |n| n.to_i &lt; 350 }
=&gt; [&quot;45&quot;, &quot;349&quot;, &quot;4&quot;, &quot;204&quot;]

# numbers between 200 and 650
&gt;&gt; '45 349 651 593 4 204'.gsub(/\d++/) { (200..650) === $&amp;.to_i ? 0 : 1 }
=&gt; &quot;1 0 1 0 1 0&quot;
</code></pre>
<h2><a class="header" href="#cheatsheet-and-summary" id="cheatsheet-and-summary">Cheatsheet and Summary</a></h2>
<table><thead><tr><th>Note</th><th>Description</th></tr></thead><tbody>
<tr><td><code>[ae;o]</code></td><td>match any of these characters once</td></tr>
<tr><td></td><td>quantifiers are applicable to character classes too</td></tr>
<tr><td><code>[3-7]</code></td><td>range of characters from <code>3</code> to <code>7</code></td></tr>
<tr><td><code>[^=b2]</code></td><td>match other than <code>=</code> or <code>b</code> or <code>2</code></td></tr>
<tr><td><code>[a-z&amp;&amp;[^aeiou]]</code></td><td>intersection of <code>a-z</code> and <code>[^aeiou]</code></td></tr>
<tr><td><code>[a-z-]</code></td><td><code>-</code> should be first/last or escaped using <code>\</code> to match literally</td></tr>
<tr><td><code>[+^]</code></td><td><code>^</code> shouldn't be first character or escaped using <code>\</code></td></tr>
<tr><td><code>[a-z\[\]\\]</code></td><td><code>[</code>, <code>]</code> and <code>\</code> should be escaped using <code>\</code></td></tr>
<tr><td><code>\w</code></td><td>similar to <code>[A-Za-z0-9_]</code> for matching word characters</td></tr>
<tr><td><code>\d</code></td><td>similar to <code>[0-9]</code> for matching digit characters</td></tr>
<tr><td><code>\s</code></td><td>similar to <code>[ \t\n\r\f\v]</code> for matching whitespace characters</td></tr>
<tr><td><code>\h</code></td><td>similar to <code>[0-9a-fA-F]</code> for matching hexadecimal characters</td></tr>
<tr><td></td><td><code>\W</code>, <code>\D</code>, <code>\S</code> and <code>\H</code> for their opposites respectively</td></tr>
<tr><td></td><td>these escapes can be used inside character class as well</td></tr>
<tr><td><code>[[:alpha:]]</code></td><td>named character set to match alphabets</td></tr>
<tr><td><code>[[:^punct:]]</code></td><td>named character set to match other than punctuation</td></tr>
<tr><td></td><td>see <a href="https://ruby-doc.org/core-2.7.1/Regexp.html#class-Regexp-label-Character+Classes">ruby-doc: Character Classes</a> for full list</td></tr>
<tr><td><code>\R</code></td><td>matches line breaks <code>\n</code>, <code>\v</code>, <code>\f</code>, <code>\r</code>, <code>\u0085</code> (next line)</td></tr>
<tr><td></td><td><code>\u2028</code> (line separator), <code>\u2029</code> (paragraph separator) or <code>\r\n</code></td></tr>
<tr><td></td><td><code>\R</code> has no special meaning inside a character class</td></tr>
</tbody></table>
<p>This chapter focused on how to create custom placeholders for limited set of characters. Grouping and character classes can be considered as two levels of abstractions. On the one hand, you can have character sets inside <code>[]</code> and on the other, you can have multiple alternations grouped inside <code>()</code> including character classes. As anchoring and quantifiers can be applied to both these abstractions, you can begin to see how regular expressions is considered a mini-programming language. In coming chapters, you'll even see how to negate groupings similar to negated character class in certain scenarios.</p>
<h2><a class="header" href="#exercises" id="exercises">Exercises</a></h2>
<p><strong>a)</strong> For the array <code>items</code>, filter all elements starting with <code>hand</code> and ending with <code>s</code> or <code>y</code> or <code>le</code>.</p>
<pre><code class="language-ruby">&gt;&gt; items = %w[-handy hand handy unhand hands handle]

##### add your solution here
=&gt; [&quot;handy&quot;, &quot;hands&quot;, &quot;handle&quot;]
</code></pre>
<p><strong>b)</strong> Replace all whole words <code>reed</code> or <code>read</code> or <code>red</code> with <code>X</code>.</p>
<pre><code class="language-ruby">&gt;&gt; ip = 'redo red credible :read: rod reed'

##### add your solution here
=&gt; &quot;redo X credible :X: rod X&quot;
</code></pre>
<p><strong>c)</strong> For the array <code>words</code>, filter all elements containing <code>e</code> or <code>i</code> followed by <code>l</code> or <code>n</code>. Note that the order mentioned should be followed.</p>
<pre><code class="language-ruby">&gt;&gt; words = %w[surrender unicorn newer door empty eel pest]

##### add your solution here
=&gt; [&quot;surrender&quot;, &quot;unicorn&quot;, &quot;eel&quot;]
</code></pre>
<p><strong>d)</strong> For the array <code>words</code>, filter all elements containing <code>e</code> or <code>i</code> and <code>l</code> or <code>n</code> in any order.</p>
<pre><code class="language-ruby">&gt;&gt; words = %w[surrender unicorn newer door empty eel pest]

##### add your solution here
=&gt; [&quot;surrender&quot;, &quot;unicorn&quot;, &quot;newer&quot;, &quot;eel&quot;]
</code></pre>
<p><strong>e)</strong> Convert the comma separated strings to corresponding <code>hash</code> objects as shown below.</p>
<pre><code class="language-ruby">&gt;&gt; row1 = 'name:rohan,maths:75,phy:89'
&gt;&gt; row2 = 'name:rose,maths:88,phy:92'

&gt;&gt; pat =        ##### add your solution here

##### add your solution here for row1
=&gt; {&quot;name&quot;=&gt;&quot;rohan&quot;, &quot;maths&quot;=&gt;&quot;75&quot;, &quot;phy&quot;=&gt;&quot;89&quot;}
##### add your solution here for row2
=&gt; {&quot;name&quot;=&gt;&quot;rose&quot;, &quot;maths&quot;=&gt;&quot;88&quot;, &quot;phy&quot;=&gt;&quot;92&quot;}
</code></pre>
<p><strong>f)</strong> Delete from <code>(</code> to the next occurrence of <code>)</code> unless they contain parentheses characters in between.</p>
<pre><code class="language-ruby">&gt;&gt; str1 = 'def factorial()'
&gt;&gt; str2 = 'a/b(division) + c%d(#modulo) - (e+(j/k-3)*4)'
&gt;&gt; str3 = 'Hi there(greeting). Nice day(a(b)'

&gt;&gt; remove_parentheses =     ##### add your solution here

&gt;&gt; str1.gsub(remove_parentheses, '')
=&gt; &quot;def factorial&quot;
&gt;&gt; str2.gsub(remove_parentheses, '')
=&gt; &quot;a/b + c%d - (e+*4)&quot;
&gt;&gt; str3.gsub(remove_parentheses, '')
=&gt; &quot;Hi there. Nice day(a&quot;
</code></pre>
<p><strong>g)</strong> For the array <code>words</code>, filter all elements not starting with <code>e</code> or <code>p</code> or <code>u</code>.</p>
<pre><code class="language-ruby">&gt;&gt; words = %w[surrender unicorn newer door empty eel pest]

##### add your solution here
=&gt; [&quot;surrender&quot;, &quot;newer&quot;, &quot;door&quot;]
</code></pre>
<p><strong>h)</strong> For the array <code>words</code>, filter all elements not containing <code>u</code> or <code>w</code> or <code>ee</code> or <code>-</code>.</p>
<pre><code class="language-ruby">&gt;&gt; words = %w[p-t you tea heel owe new reed ear]

##### add your solution here
=&gt; [&quot;tea&quot;, &quot;ear&quot;]
</code></pre>
<p><strong>i)</strong> The given input strings contain fields separated by <code>,</code> and fields can be empty too. Replace last three fields with <code>WHTSZ323</code>.</p>
<pre><code class="language-ruby">&gt;&gt; row1 = '(2),kite,12,,D,C,,'
&gt;&gt; row2 = 'hi,bye,sun,moon'

&gt;&gt; pat =        ##### add your solution here

##### add your solution here for row1
=&gt; &quot;(2),kite,12,,D,WHTSZ323&quot;
##### add your solution here for row2
=&gt; &quot;hi,WHTSZ323&quot;
</code></pre>
<p><strong>j)</strong> Split the given strings based on consecutive sequence of digit or whitespace characters.</p>
<pre><code class="language-ruby">&gt;&gt; str1 = &quot;lion \t Ink32onion Nice&quot;
&gt;&gt; str2 = &quot;**1\f2\n3star\t7 77\r**&quot;

&gt;&gt; pat =        ##### add your solution here

&gt;&gt; str1.split(pat)
=&gt; [&quot;lion&quot;, &quot;Ink&quot;, &quot;onion&quot;, &quot;Nice&quot;]
&gt;&gt; str2.split(pat)
=&gt; [&quot;**&quot;, &quot;star&quot;, &quot;**&quot;]
</code></pre>
<p><strong>k)</strong> Delete all occurrences of the sequence <code>&lt;characters&gt;</code> where <code>characters</code> is one or more non <code>&gt;</code> characters and cannot be empty.</p>
<pre><code class="language-ruby">&gt;&gt; ip = 'a&lt;apple&gt; 1&lt;&gt; b&lt;bye&gt; 2&lt;&gt; c&lt;cat&gt;'

##### add your solution here
=&gt; &quot;a 1&lt;&gt; b 2&lt;&gt; c&quot;
</code></pre>
<p><strong>l)</strong> <code>\b[a-z](on|no)[a-z]\b</code> is same as <code>\b[a-z][on]{2}[a-z]\b</code>. True or False? Sample input lines shown below might help to understand the differences, if any.</p>
<pre><code class="language-ruby">&gt;&gt; puts &quot;known\nmood\nknow\npony\ninns&quot;
known
mood
know
pony
inns
</code></pre>
<p><strong>m)</strong> For the given array, filter all elements containing any number sequence greater than <code>624</code>.</p>
<pre><code class="language-ruby">&gt;&gt; items = ['h0000432ab', 'car00625', '42_624 0512', '96 foo1234baz 3.14 2']

##### add your solution here
=&gt; [&quot;car00625&quot;, &quot;96 foo1234baz 3.14 2&quot;]
</code></pre>
<p><strong>n)</strong> Count the maximum depth of nested braces for the given strings. Unbalanced or wrongly ordered braces should return <code>-1</code>. Note that this will require a mix of regular expressions and Ruby code.</p>
<pre><code class="language-ruby">?&gt; def max_nested_braces(ip)
##### add your solution here
&gt;&gt; end

&gt;&gt; max_nested_braces('a*b')
=&gt; 0
&gt;&gt; max_nested_braces('}a+b{')
=&gt; -1
&gt;&gt; max_nested_braces('a*b+{}')
=&gt; 1
&gt;&gt; max_nested_braces('{{a+2}*{b+c}+e}')
=&gt; 2
&gt;&gt; max_nested_braces('{{a+2}*{b+{c*d}}+e}')
=&gt; 3
&gt;&gt; max_nested_braces(&quot;{{a+2}*{\n{b+{c*d}}+e*d}}&quot;)
=&gt; 4
&gt;&gt; max_nested_braces('a*{b+c*{e*3.14}}}')
=&gt; -1
</code></pre>
<p><strong>o)</strong> By default, <code>split</code> method will split on whitespace and remove empty strings from the result. Which regexp based method would you use to replicate this functionality?</p>
<pre><code class="language-ruby">&gt;&gt; ip = &quot; \t\r  so  pole\t\t\t\n\nlit in to \r\n\v\f  &quot;

&gt;&gt; ip.split
=&gt; [&quot;so&quot;, &quot;pole&quot;, &quot;lit&quot;, &quot;in&quot;, &quot;to&quot;]

##### add your solution here
=&gt; [&quot;so&quot;, &quot;pole&quot;, &quot;lit&quot;, &quot;in&quot;, &quot;to&quot;]
</code></pre>
<p><strong>p)</strong> Convert the given input string to two different arrays as shown below. You can optimize the regexp based on characters present in the input string.</p>
<pre><code class="language-ruby">&gt;&gt; ip = &quot;price_42 roast^\t\n^-ice==cat\neast&quot;

##### add your solution here
=&gt; [&quot;price_42&quot;, &quot;roast&quot;, &quot;ice&quot;, &quot;cat&quot;, &quot;east&quot;]

##### add your solution here
=&gt; [&quot;price_42&quot;, &quot; &quot;, &quot;roast&quot;, &quot;^\t\n^-&quot;, &quot;ice&quot;, &quot;==&quot;, &quot;cat&quot;, &quot;\n&quot;, &quot;east&quot;]
</code></pre>
<p><strong>q)</strong> Filter all elements whose first non-whitespace character is not a <code>#</code> character. Any element made up of only whitespace characters should be ignored as well.</p>
<pre><code class="language-ruby">&gt;&gt; items = ['    #comment', &quot;\t\napple #42&quot;, '#oops', 'sure', 'no#1', &quot;\t\r\f&quot;]

##### add your solution here
=&gt; [&quot;\t\napple #42&quot;, &quot;sure&quot;, &quot;no#1&quot;]
</code></pre>
<p><strong>r)</strong> Extract all whole words for the given input strings. However, based on user input <code>ignore</code>, do not match words if they contain any character present in the <code>ignore</code> variable. Assume that <code>ignore</code> variable will not contain any regexp metacharacter.</p>
<pre><code class="language-ruby">&gt;&gt; s1 = 'match after the last newline character'
&gt;&gt; s2 = 'and then you want to test'

&gt;&gt; ignore = 'aty'
&gt;&gt; pat =        ##### add your solution here
&gt;&gt; s1.scan(pat)
=&gt; [&quot;newline&quot;]
&gt;&gt; s2.scan(pat)
=&gt; []

&gt;&gt; ignore = 'esw'
&gt;&gt; pat =        ##### add your solution here
&gt;&gt; s1.scan(pat)
=&gt; [&quot;match&quot;]
&gt;&gt; s2.scan(pat)
=&gt; [&quot;and&quot;, &quot;you&quot;, &quot;to&quot;]
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="working-with-matched-portions.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="groupings-and-backreferences.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="working-with-matched-portions.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="groupings-and-backreferences.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
