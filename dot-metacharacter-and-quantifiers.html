<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Dot metacharacter and Quantifiers - Ruby Regexp</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Example based guide to mastering Ruby Regexp">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
        <link rel="stylesheet" href="custom.css">
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="cover.html">Cover</a></li><li class="chapter-item expanded affix "><a href="buy.html">Buy PDF/EPUB versions</a></li><li class="chapter-item expanded "><a href="preface.html"><strong aria-hidden="true">1.</strong> Preface</a></li><li class="chapter-item expanded "><a href="why-is-it-needed.html"><strong aria-hidden="true">2.</strong> Why is it needed?</a></li><li class="chapter-item expanded "><a href="regexp-introduction.html"><strong aria-hidden="true">3.</strong> Regexp introduction</a></li><li class="chapter-item expanded "><a href="anchors.html"><strong aria-hidden="true">4.</strong> Anchors</a></li><li class="chapter-item expanded "><a href="alternation-and-grouping.html"><strong aria-hidden="true">5.</strong> Alternation and Grouping</a></li><li class="chapter-item expanded "><a href="escaping-metacharacters.html"><strong aria-hidden="true">6.</strong> Escaping metacharacters</a></li><li class="chapter-item expanded "><a href="dot-metacharacter-and-quantifiers.html" class="active"><strong aria-hidden="true">7.</strong> Dot metacharacter and Quantifiers</a></li><li class="chapter-item expanded "><a href="interlude-tools-for-debugging-and-visualization.html"><strong aria-hidden="true">8.</strong> Interlude: Tools for debugging and visualization</a></li><li class="chapter-item expanded "><a href="working-with-matched-portions.html"><strong aria-hidden="true">9.</strong> Working with matched portions</a></li><li class="chapter-item expanded "><a href="character-class.html"><strong aria-hidden="true">10.</strong> Character class</a></li><li class="chapter-item expanded "><a href="groupings-and-backreferences.html"><strong aria-hidden="true">11.</strong> Groupings and backreferences</a></li><li class="chapter-item expanded "><a href="interlude-common-tasks.html"><strong aria-hidden="true">12.</strong> Interlude: Common tasks</a></li><li class="chapter-item expanded "><a href="lookarounds.html"><strong aria-hidden="true">13.</strong> Lookarounds</a></li><li class="chapter-item expanded "><a href="modifiers.html"><strong aria-hidden="true">14.</strong> Modifiers</a></li><li class="chapter-item expanded "><a href="unicode.html"><strong aria-hidden="true">15.</strong> Unicode</a></li><li class="chapter-item expanded "><a href="further-reading.html"><strong aria-hidden="true">16.</strong> Further Reading</a></li><li class="chapter-item expanded "><a href="Exercise_solutions.html"><strong aria-hidden="true">17.</strong> Exercise Solutions</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Ruby Regexp</h1>

                    <div class="right-buttons">
                        
                        <a href="https://github.com/learnbyexample/Ruby_Regexp" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#dot-metacharacter-and-quantifiers" id="dot-metacharacter-and-quantifiers">Dot metacharacter and Quantifiers</a></h1>
<p>This chapter introduces dot metacharacter and quantifiers. As the name implies, quantifiers allows you to specify how many times a character or grouping should be matched. With <code>*</code> string operator, you can do something like <code>'no' * 5</code> to get <code>&quot;nonononono&quot;</code>. This saves you manual repetition as well as gives the ability to programmatically repeat a string object as many times as you need. Quantifiers support this simple repetition as well as ways to specify a range of repetition. This range has the flexibility of being bounded or unbounded with respect to start and end values. Combined with dot metacharacter (and alternation if needed), quantifiers allow you to construct conditional AND logic between patterns.</p>
<h2><a class="header" href="#dot-metacharacter" id="dot-metacharacter">Dot metacharacter</a></h2>
<p>The dot metacharacter matches any character except the newline character.</p>
<pre><code class="language-ruby"># matches character 'c', any character and then character 't'
&gt;&gt; 'tac tin c.t abc;tuv acute'.gsub(/c.t/, 'X')
=&gt; &quot;taXin X abXuv aXe&quot;

# matches character 'r', any two characters and then character 'd'
&gt;&gt; 'breadth markedly reported overrides'.gsub(/r..d/) { |s| s.upcase }
=&gt; &quot;bREADth maRKEDly repoRTED oveRRIDes&quot;

# matches character '2', any character and then character '3'
&gt;&gt; &quot;42\t33&quot;.sub(/2.3/, '8')
=&gt; &quot;483&quot;
</code></pre>
<p>See <a href="./modifiers.html#m-modifier">m modifier</a> section to know how <code>.</code> can match newline as well. Chapter <a href="./character-class.html#character-class">Character class</a> will discuss how to define your own custom placeholder for limited set of characters.</p>
<h2><a class="header" href="#split-method" id="split-method">split method</a></h2>
<p>This chapter will additionally use <code>split</code> method to illustrate examples. The <code>split</code> method separates the string based on given regexp (or string) and returns an array of strings.</p>
<pre><code class="language-ruby"># same as: 'apple-85-mango-70'.split('-')
&gt;&gt; 'apple-85-mango-70'.split(/-/)
=&gt; [&quot;apple&quot;, &quot;85&quot;, &quot;mango&quot;, &quot;70&quot;]

&gt;&gt; 'bus:3:car:5:van'.split(/:.:/)
=&gt; [&quot;bus&quot;, &quot;car&quot;, &quot;van&quot;]

# optional limit can be specified as second argument
# when limit is positive, you get maximum of limit-1 splits
&gt;&gt; 'apple-85-mango-70'.split(/-/, 2)
=&gt; [&quot;apple&quot;, &quot;85-mango-70&quot;]
</code></pre>
<p>See <a href="./working-with-matched-portions.html#split-with-capture-groups">split with capture groups</a> section for details of how capture groups affect the output of <code>split</code> method.</p>
<h2><a class="header" href="#greedy-quantifiers" id="greedy-quantifiers">Greedy quantifiers</a></h2>
<p>Quantifiers have functionality like the string repetition operator and range method. They can be applied to both characters and groupings (and more, as you'll see in later chapters). Apart from ability to specify exact quantity and bounded range, these can also match unbounded varying quantities. If the input string can satisfy a pattern with varying quantities in multiple ways, you can choose among three types of quantifiers to narrow down possibilities. In this section, <strong>greedy</strong> type of quantifiers is covered.</p>
<p>First up, the <code>?</code> metacharacter which quantifies a character or group to match <code>0</code> or <code>1</code> times. In other words, you make that character or group as something to be optionally matched. This leads to a terser regexp compared to alternation and grouping.</p>
<pre><code class="language-ruby"># same as: /ear|ar/
&gt;&gt; 'far feat flare fear'.gsub(/e?ar/, 'X')
=&gt; &quot;fX feat flXe fX&quot;

# same as: /\bpar(t|)\b/
&gt;&gt; 'par spare part party'.gsub(/\bpart?\b/, 'X')
=&gt; &quot;X spare X party&quot;

# same as: /\b(re.d|red)\b/
&gt;&gt; words = %w[red read ready re;d road redo reed rod]
&gt;&gt; words.grep(/\bre.?d\b/)
=&gt; [&quot;red&quot;, &quot;read&quot;, &quot;re;d&quot;, &quot;reed&quot;]

# same as: /part|parrot/
&gt;&gt; 'par part parrot parent'.gsub(/par(ro)?t/, 'X')
=&gt; &quot;par X X parent&quot;
# same as: /part|parrot|parent/
&gt;&gt; 'par part parrot parent'.gsub(/par(en|ro)?t/, 'X')
=&gt; &quot;par X X X&quot;
</code></pre>
<p>The <code>*</code> metacharacter quantifies a character or group to match <code>0</code> or more times. There is no upper bound, more details will be discussed later in this chapter.</p>
<pre><code class="language-ruby"># match 't' followed by zero or more of 'a' followed by 'r'
&gt;&gt; 'tr tear tare steer sitaara'.gsub(/ta*r/, 'X')
=&gt; &quot;X tear Xe steer siXa&quot;

# match 't' followed by zero or more of 'e' or 'a' followed by 'r'
&gt;&gt; 'tr tear tare steer sitaara'.gsub(/t(e|a)*r/, 'X')
=&gt; &quot;X X Xe sX siXa&quot;

# match zero or more of '1' followed by '2'
&gt;&gt; '3111111111125111142'.gsub(/1*2/, 'X')
=&gt; &quot;3X511114X&quot;
</code></pre>
<p>Here's some examples with <code>split</code> and related methods. <code>partition</code> splits the input string on the first match and the text matched by the regexp is also present in the output. <code>rpartition</code> is like <code>partition</code> but splits on the last match.</p>
<pre><code class="language-ruby"># note how '25' and '42' gets split, there is '1' zero times in between them
&gt;&gt; '3111111111125111142'.split(/1*/)
=&gt; [&quot;3&quot;, &quot;2&quot;, &quot;5&quot;, &quot;4&quot;, &quot;2&quot;]
# there is '1' zero times at end of string as well, note the use of -1 for limit
&gt;&gt; '3111111111125111142'.split(/1*/, -1)
=&gt; [&quot;3&quot;, &quot;2&quot;, &quot;5&quot;, &quot;4&quot;, &quot;2&quot;, &quot;&quot;]

&gt;&gt; '3111111111125111142'.partition(/1*2/)
=&gt; [&quot;3&quot;, &quot;11111111112&quot;, &quot;5111142&quot;]

# last element is empty because there is nothing after 2 at the end of string
&gt;&gt; '3111111111125111142'.rpartition(/1*2/)
=&gt; [&quot;311111111112511114&quot;, &quot;2&quot;, &quot;&quot;]
</code></pre>
<p>The <code>+</code> metacharacter quantifies a character or group to match <code>1</code> or more times. Similar to <code>*</code> quantifier, there is no upper bound. More importantly, this doesn't have surprises like matching empty string in between patterns or at the end of string.</p>
<pre><code class="language-ruby">&gt;&gt; 'tr tear tare steer sitaara'.gsub(/ta+r/, 'X')
=&gt; &quot;tr tear Xe steer siXa&quot;
&gt;&gt; 'tr tear tare steer sitaara'.gsub(/t(e|a)+r/, 'X')
=&gt; &quot;tr X Xe sX siXa&quot;

&gt;&gt; '3111111111125111142'.gsub(/1+2/, 'X')
=&gt; &quot;3X5111142&quot;
&gt;&gt; '3111111111125111142'.split(/1+/)
=&gt; [&quot;3&quot;, &quot;25&quot;, &quot;42&quot;]
</code></pre>
<p>You can specify a range of integer numbers, both bounded and unbounded, using <code>{}</code> metacharacters. There are four ways to use this quantifier as listed below:</p>
<table><thead><tr><th>Pattern</th><th>Description</th></tr></thead><tbody>
<tr><td><code>{m,n}</code></td><td>match <code>m</code> to <code>n</code> times</td></tr>
<tr><td><code>{m,}</code></td><td>match at least <code>m</code> times</td></tr>
<tr><td><code>{,n}</code></td><td>match up to <code>n</code> times (including <code>0</code> times)</td></tr>
<tr><td><code>{n}</code></td><td>match exactly <code>n</code> times</td></tr>
</tbody></table>
<pre><code class="language-ruby">&gt;&gt; demo = %w[abc ac adc abbc xabbbcz bbb bc abbbbbc]

&gt;&gt; demo.grep(/ab{1,4}c/)
=&gt; [&quot;abc&quot;, &quot;abbc&quot;, &quot;xabbbcz&quot;]
&gt;&gt; demo.grep(/ab{3,}c/)
=&gt; [&quot;xabbbcz&quot;, &quot;abbbbbc&quot;]
&gt;&gt; demo.grep(/ab{,2}c/)
=&gt; [&quot;abc&quot;, &quot;ac&quot;, &quot;abbc&quot;]
&gt;&gt; demo.grep(/ab{3}c/)
=&gt; [&quot;xabbbcz&quot;]
</code></pre>
<blockquote>
<p><img src="images/info.svg" alt="info" /> The <code>{}</code> metacharacters have to be escaped to match them literally. However, unlike <code>()</code> metacharacters, these have lot more leeway. For example, escaping <code>{</code> alone is enough, or if it doesn't conform strictly to any of the four forms listed above, escaping is not needed at all. Also, if you are applying <code>{}</code> quantifier to <code>#</code> character, you need to escape the <code>#</code> to override interpolation.</p>
</blockquote>
<h2><a class="header" href="#and-conditional" id="and-conditional">AND conditional</a></h2>
<p>Next up, how to construct AND conditional using dot metacharacter and quantifiers.</p>
<pre><code class="language-ruby"># match 'Error' followed by zero or more characters followed by 'valid'
&gt;&gt; 'Error: not a valid input'.match?(/Error.*valid/)
=&gt; true

&gt;&gt; 'Error: key not found'.match?(/Error.*valid/)
=&gt; false
</code></pre>
<p>To allow matching in any order, you'll have to bring in alternation as well. That is somewhat manageable for 2 or 3 patterns. See <a href="./lookarounds.html#and-conditional-with-lookarounds">AND conditional with lookarounds</a> section for an easier approach.</p>
<pre><code class="language-ruby">&gt;&gt; seq1, seq2 = ['cat and dog', 'dog and cat']
&gt;&gt; seq1.match?(/cat.*dog|dog.*cat/)
=&gt; true
&gt;&gt; seq2.match?(/cat.*dog|dog.*cat/)
=&gt; true

# if you just need true/false result, this would be a scalable approach
&gt;&gt; patterns = [/cat/, /dog/]
&gt;&gt; patterns.all? { |re| seq1.match?(re) }
=&gt; true
&gt;&gt; patterns.all? { |re| seq2.match?(re) }
=&gt; true
</code></pre>
<h2><a class="header" href="#what-does-greedy-mean" id="what-does-greedy-mean">What does greedy mean?</a></h2>
<p>When you are using the <code>?</code> quantifier, how does Ruby decide to match <code>0</code> or <code>1</code> times, if both quantities can satisfy the regexp?  For example, consider this substitution expression <code>'foot'.sub(/f.?o/, 'X')</code> — should <code>foo</code> be replaced or <code>fo</code>? It will always replace <code>foo</code> because these are <strong>greedy</strong> quantifiers, meaning they try to match as much as possible.</p>
<pre><code class="language-ruby">&gt;&gt; 'foot'.sub(/f.?o/, 'X')
=&gt; &quot;Xt&quot;

# a more practical example
# prefix '&lt;' with '\' if it is not already prefixed
# both '&lt;' and '\&lt;' will get replaced with '\&lt;'
&gt;&gt; puts 'blah \&lt; foo &lt; bar \&lt; blah &lt; baz'.gsub(/\\?&lt;/, '\&lt;')
blah \&lt; foo \&lt; bar \&lt; blah \&lt; baz

# say goodbye to /handful|handy|hand/ shenanigans
&gt;&gt; 'hand handy handful'.gsub(/hand(y|ful)?/, 'X')
=&gt; &quot;X X X&quot;
</code></pre>
<p>But wait, then how did <code>/Error.*valid/</code> example work? Shouldn't <code>.*</code> consume all the characters after <code>Error</code>? Good question. The regular expression engine actually does consume all the characters. Then realizing that the regexp fails, it gives back one character from end of string and checks again if the overall regexp is satisfied. This process is repeated until a match is found or failure is confirmed. In regular expression parlance, this is called <strong>backtracking</strong>.</p>
<pre><code class="language-ruby">&gt;&gt; sentence = 'that is quite a fabricated tale'

# /t.*a/ will always match from first 't' to last 'a'
# also, note that 'sub' is being used here, not 'gsub'
&gt;&gt; sentence.sub(/t.*a/, 'X')
=&gt; &quot;Xle&quot;
&gt;&gt; 'star'.sub(/t.*a/, 'X')
=&gt; &quot;sXr&quot;

# matching first 't' to last 'a' for t.*a won't work for these cases
# the regexp engine backtracks until .*q matches and so on
&gt;&gt; sentence.sub(/t.*a.*q.*f/, 'X')
=&gt; &quot;Xabricated tale&quot;
&gt;&gt; sentence.sub(/t.*a.*u/, 'X')
=&gt; &quot;Xite a fabricated tale&quot;
</code></pre>
<blockquote>
<p><img src="images/warning.svg" alt="warning" /> Backtracking can be quite time consuming for certain corner cases (see <a href="https://ruby-doc.org/core-2.7.1/Regexp.html#class-Regexp-label-Performance">ruby-doc: Regexp Performance</a>). Or even catastrophic (see <a href="https://blog.cloudflare.com/details-of-the-cloudflare-outage-on-july-2-2019/">cloudflare: Details of the Cloudflare outage on July 2, 2019</a>).</p>
</blockquote>
<h2><a class="header" href="#non-greedy-quantifiers" id="non-greedy-quantifiers">Non-greedy quantifiers</a></h2>
<p>As the name implies, these quantifiers will try to match as minimally as possible. Also known as <strong>lazy</strong> or <strong>reluctant</strong> quantifiers. Appending a <code>?</code> to greedy quantifiers makes them non-greedy.</p>
<pre><code class="language-ruby">&gt;&gt; 'foot'.sub(/f.??o/, 'X')
=&gt; &quot;Xot&quot;
&gt;&gt; 'frost'.sub(/f.??o/, 'X')
=&gt; &quot;Xst&quot;

&gt;&gt; '123456789'.sub(/.{2,5}?/, 'X')
=&gt; &quot;X3456789&quot;

&gt;&gt; 'green:3.14:teal::brown:oh!:blue'.split(/:.*?:/)
=&gt; [&quot;green&quot;, &quot;teal&quot;, &quot;brown&quot;, &quot;blue&quot;]
</code></pre>
<p>Like greedy quantifiers, lazy quantifiers will try to satisfy the overall regexp.</p>
<pre><code class="language-ruby">&gt;&gt; sentence = 'that is quite a fabricated tale'

# /t.*?a/ will always match from first 't' to first 'a'
&gt;&gt; sentence.sub(/t.*?a/, 'X')
=&gt; &quot;Xt is quite a fabricated tale&quot;

# matching first 't' to first 'a' for t.*?a won't work for this case
# so, regexp engine will move forward until .*?f matches and so on
&gt;&gt; sentence.sub(/t.*?a.*?f/, 'X')
=&gt; &quot;Xabricated tale&quot;
# this matches last 'e' after 'q' to satisfy the anchor requirement
&gt;&gt; sentence.sub(/q.*?e$/, 'X')
=&gt; &quot;that is X&quot;
</code></pre>
<h2><a class="header" href="#possessive-quantifiers" id="possessive-quantifiers">Possessive quantifiers</a></h2>
<p>Appending a <code>+</code> to greedy quantifiers makes them possessive quantifiers. These are like greedy quantifiers, but without the backtracking. So, something like <code>/Error.*+valid/</code> will never match because <code>.*+</code> will consume all the remaining characters. If both the greedy and possessive quantifier versions are functionally equivalent, then possessive is preferred because it will fail faster for non-matching cases.</p>
<pre><code class="language-ruby"># functionally equivalent greedy and possessive versions
&gt;&gt; %w[abc ac adc abbc xabbbcz bbb bc abbbbbc].grep(/ab*c/)
=&gt; [&quot;abc&quot;, &quot;ac&quot;, &quot;abbc&quot;, &quot;xabbbcz&quot;, &quot;abbbbbc&quot;]
&gt;&gt; %w[abc ac adc abbc xabbbcz bbb bc abbbbbc].grep(/ab*+c/)
=&gt; [&quot;abc&quot;, &quot;ac&quot;, &quot;abbc&quot;, &quot;xabbbcz&quot;, &quot;abbbbbc&quot;]

# different results
# numbers &gt;= 100 if there are leading zeros
# \d will be discussed in a later chapter, it matches all digit characters
&gt;&gt; '0501 035 154 12 26 98234'.gsub(/\b0*\d{3,}\b/, 'X')
=&gt; &quot;X X X 12 26 X&quot;
&gt;&gt; '0501 035 154 12 26 98234'.gsub(/\b0*+\d{3,}\b/, 'X')
=&gt; &quot;X 035 X 12 26 X&quot;
</code></pre>
<p>The effect of possessive quantifier can also be expressed using <strong>atomic grouping</strong>. The syntax is <code>(?&gt;pat)</code>, where <code>pat</code> is an abbreviation for a portion of regular expression pattern. In later chapters you'll see more such special groupings.</p>
<pre><code class="language-ruby"># same as: /(b|o)++/
&gt;&gt; 'abbbc foooooot'.gsub(/(?&gt;(b|o)+)/, 'X')
=&gt; &quot;aXc fXt&quot;

# same as: /\b0*+\d{3,}\b/
&gt;&gt; '0501 035 154 12 26 98234'.gsub(/\b(?&gt;0*)\d{3,}\b/, 'X')
=&gt; &quot;X 035 X 12 26 X&quot;
</code></pre>
<h2><a class="header" href="#cheatsheet-and-summary" id="cheatsheet-and-summary">Cheatsheet and Summary</a></h2>
<table><thead><tr><th>Note</th><th>Description</th></tr></thead><tbody>
<tr><td><code>.</code></td><td>match any character except the newline character</td></tr>
<tr><td>greedy</td><td>match as much as possible</td></tr>
<tr><td><code>?</code></td><td>greedy quantifier, match <code>0</code> or <code>1</code> times</td></tr>
<tr><td><code>*</code></td><td>greedy quantifier, match <code>0</code> or more times</td></tr>
<tr><td><code>+</code></td><td>greedy quantifier, match <code>1</code> or more times</td></tr>
<tr><td><code>{m,n}</code></td><td>greedy quantifier, match <code>m</code> to <code>n</code> times</td></tr>
<tr><td><code>{m,}</code></td><td>greedy quantifier, match at least <code>m</code> times</td></tr>
<tr><td><code>{,n}</code></td><td>greedy quantifier, match up to <code>n</code> times (including <code>0</code> times)</td></tr>
<tr><td><code>{n}</code></td><td>greedy quantifier, match exactly <code>n</code> times</td></tr>
<tr><td><code>pat1.*pat2</code></td><td>any number of characters between <code>pat1</code> and <code>pat2</code></td></tr>
<tr><td><code>pat1.*pat2|pat2.*pat1</code></td><td>match both <code>pat1</code> and <code>pat2</code> in any order</td></tr>
<tr><td>non-greedy</td><td>append <code>?</code> to greedy quantifier</td></tr>
<tr><td></td><td>match as minimally as possible</td></tr>
<tr><td>possessive</td><td>append <code>+</code> to greedy quantifier</td></tr>
<tr><td></td><td>like greedy, but no backtracking</td></tr>
<tr><td><code>(?&gt;pat)</code></td><td>atomic grouping, similar to possessive quantifier</td></tr>
<tr><td><code>s.split(/pat/)</code></td><td>split a string based on <code>pat</code></td></tr>
<tr><td></td><td>accepts an optional limit argument to control no. of splits</td></tr>
<tr><td><code>s.partition(/pat/)</code></td><td>returns array of 3 elements based on first match of <code>pat</code></td></tr>
<tr><td></td><td>portion before match, matched portion, portion after match</td></tr>
<tr><td><code>s.rpartition(/pat/)</code></td><td>returns array of 3 elements based on last match of <code>pat</code></td></tr>
</tbody></table>
<p>This chapter introduced the concept of specifying a placeholder instead of fixed string. When combined with quantifiers, you've seen a glimpse of how a simple regexp can match wide range of text. In coming chapters, you'll learn how to create your own restricted set of placeholder characters.</p>
<h2><a class="header" href="#exercises" id="exercises">Exercises</a></h2>
<blockquote>
<p><img src="images/info.svg" alt="info" /> Since <code>.</code> metacharacter doesn't match newline character by default, assume that the input strings in the following exercises will not contain newline characters.</p>
</blockquote>
<p><strong>a)</strong> Replace <code>42//5</code> or <code>42/5</code> with <code>8</code> for the given input.</p>
<pre><code class="language-ruby">&gt;&gt; ip = 'a+42//5-c pressure*3+42/5-14256'

&gt;&gt; ip.gsub()        ##### add your solution here
=&gt; &quot;a+8-c pressure*3+8-14256&quot;
</code></pre>
<p><strong>b)</strong> For the array <code>items</code>, filter all elements starting with <code>hand</code> and ending with at most one more character or <code>le</code>.</p>
<pre><code class="language-ruby">&gt;&gt; items = %w[handed hand handled handy unhand hands handle]

&gt;&gt; items.grep()     ##### add your solution here
=&gt; [&quot;hand&quot;, &quot;handy&quot;, &quot;hands&quot;, &quot;handle&quot;]
</code></pre>
<p><strong>c)</strong> Use <code>split</code> method to get the output as shown for the given input strings.</p>
<pre><code class="language-ruby">&gt;&gt; eqn1 = 'a+42//5-c'
&gt;&gt; eqn2 = 'pressure*3+42/5-14256'
&gt;&gt; eqn3 = 'r*42-5/3+42///5-42/53+a'

&gt;&gt; pat =        ##### add your solution here

&gt;&gt; eqn1.split(pat)
=&gt; [&quot;a+&quot;, &quot;-c&quot;]
&gt;&gt; eqn2.split(pat)
=&gt; [&quot;pressure*3+&quot;, &quot;-14256&quot;]
&gt;&gt; eqn3.split(pat)
=&gt; [&quot;r*42-5/3+42///5-&quot;, &quot;3+a&quot;]
</code></pre>
<p><strong>d)</strong> For the given input strings, remove everything from the first occurrence of <code>i</code> till end of the string.</p>
<pre><code class="language-ruby">&gt;&gt; s1 = 'remove the special meaning of such constructs'
&gt;&gt; s2 = 'characters while constructing'

&gt;&gt; pat =        ##### add your solution here

&gt;&gt; s1.sub(pat, '')
=&gt; &quot;remove the spec&quot;
&gt;&gt; s2.sub(pat, '')
=&gt; &quot;characters wh&quot;
</code></pre>
<p><strong>e)</strong> For the given strings, construct a regexp to get output as shown.</p>
<pre><code class="language-ruby">&gt;&gt; str1 = 'a+b(addition)'
&gt;&gt; str2 = 'a/b(division) + c%d(#modulo)'
&gt;&gt; str3 = 'Hi there(greeting). Nice day(a(b)'

&gt;&gt; remove_parentheses =     ##### add your solution here

&gt;&gt; str1.gsub(remove_parentheses, '')
=&gt; &quot;a+b&quot;
&gt;&gt; str2.gsub(remove_parentheses, '')
=&gt; &quot;a/b + c%d&quot;
&gt;&gt; str3.gsub(remove_parentheses, '')
=&gt; &quot;Hi there. Nice day&quot;
</code></pre>
<p><strong>f)</strong> Correct the given regexp to get the expected output.</p>
<pre><code class="language-ruby">&gt;&gt; words = 'plink incoming tint winter in caution sentient'

# wrong output
&gt;&gt; change = /int|in|ion|ing|inco|inter|ink/
&gt;&gt; words.gsub(change, 'X')
=&gt; &quot;plXk XcomXg tX wXer X cautX sentient&quot;

# expected output
&gt;&gt; change =     ##### add your solution here
&gt;&gt; words.gsub(change, 'X')
=&gt; &quot;plX XmX tX wX X cautX sentient&quot;
</code></pre>
<p><strong>g)</strong> For the given greedy quantifiers, what would be the equivalent form using <code>{m,n}</code> representation?</p>
<ul>
<li><code>?</code> is same as</li>
<li><code>*</code> is same as</li>
<li><code>+</code> is same as</li>
</ul>
<p><strong>h)</strong> <code>(a*|b*)</code> is same as <code>(a|b)*</code> — true or false?</p>
<p><strong>i)</strong> For the given input strings, remove everything from the first occurrence of <code>test</code> (irrespective of case) till end of the string, provided <code>test</code> isn't at the end of the string.</p>
<pre><code class="language-ruby">&gt;&gt; s1 = 'this is a Test'
&gt;&gt; s2 = 'always test your RE for corner cases'
&gt;&gt; s3 = 'a TEST of skill tests?'

&gt;&gt; pat =        ##### add your solution here

&gt;&gt; s1.sub(pat, '')
=&gt; &quot;this is a Test&quot;
&gt;&gt; s2.sub(pat, '')
=&gt; &quot;always &quot;
&gt;&gt; s3.sub(pat, '')
=&gt; &quot;a &quot;
</code></pre>
<p><strong>j)</strong> For the input array <code>words</code>, filter all elements starting with <code>s</code> and containing <code>e</code> and <code>t</code> in any order.</p>
<pre><code class="language-ruby">&gt;&gt; words = %w[sequoia subtle exhibit asset sets tests site]

&gt;&gt; words.grep()     ##### add your solution here
=&gt; [&quot;subtle&quot;, &quot;sets&quot;, &quot;site&quot;]
</code></pre>
<p><strong>k)</strong> For the input array <code>words</code>, remove all elements having less than <code>6</code> characters.</p>
<pre><code class="language-ruby">&gt;&gt; words = %w[sequoia subtle exhibit asset sets tests site]

&gt;&gt; words.grep()     ##### add your solution here
=&gt; [&quot;sequoia&quot;, &quot;subtle&quot;, &quot;exhibit&quot;]
</code></pre>
<p><strong>l)</strong> For the input array <code>words</code>, filter all elements starting with <code>s</code> or <code>t</code> and having a maximum of <code>6</code> characters.</p>
<pre><code class="language-ruby">&gt;&gt; words = %w[sequoia subtle exhibit asset sets tests site]

&gt;&gt; words.grep()     ##### add your solution here
=&gt; [&quot;subtle&quot;, &quot;sets&quot;, &quot;tests&quot;, &quot;site&quot;]
</code></pre>
<p><strong>m)</strong> Can you reason out why this code results in the output shown? The aim was to remove all <code>&lt;characters&gt;</code> patterns but not the <code>&lt;&gt;</code> ones. The expected result was <code>'a 1&lt;&gt; b 2&lt;&gt; c'</code>.</p>
<pre><code class="language-ruby">&gt;&gt; ip = 'a&lt;apple&gt; 1&lt;&gt; b&lt;bye&gt; 2&lt;&gt; c&lt;cat&gt;'

&gt;&gt; ip.gsub(/&lt;.+?&gt;/, '')
=&gt; &quot;a 1 2&quot;
</code></pre>
<p><strong>n)</strong> Use <code>split</code> method to get the output as shown below for given input strings.</p>
<pre><code class="language-ruby">&gt;&gt; s1 = 'go there  ::   this :: that'
&gt;&gt; s2 = 'a::b :: c::d e::f :: 4::5'
&gt;&gt; s3 = '42:: hi::bye::see :: carefully'

&gt;&gt; pat =        ##### add your solution here

&gt;&gt; s1.split(pat, 2)
=&gt; [&quot;go there&quot;, &quot;this :: that&quot;]
&gt;&gt; s2.split(pat, 2)
=&gt; [&quot;a::b&quot;, &quot;c::d e::f :: 4::5&quot;]
&gt;&gt; s3.split(pat, 2)
=&gt; [&quot;42:: hi::bye::see&quot;, &quot;carefully&quot;]
</code></pre>
<p><strong>o)</strong> For the given input strings, match if the string starts with optional space characters followed by at least two <code>#</code> characters.</p>
<pre><code class="language-ruby">&gt;&gt; s1 = '   ## header2'
&gt;&gt; s2 = '#### header4'
&gt;&gt; s3 = '# comment'
&gt;&gt; s4 = 'normal string'
&gt;&gt; s5 = 'nope ## not this'

&gt;&gt; pat =        ##### add your solution here

&gt;&gt; s1.match?(pat)
=&gt; true
&gt;&gt; s2.match?(pat)
=&gt; true
&gt;&gt; s3.match?(pat)
=&gt; false
&gt;&gt; s4.match?(pat)
=&gt; false
&gt;&gt; s5.match?(pat)
=&gt; false
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="escaping-metacharacters.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="interlude-tools-for-debugging-and-visualization.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="escaping-metacharacters.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="interlude-tools-for-debugging-and-visualization.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
